# Load packages, read data, specify input parameters

suppressPackageStartupMessages(library(here))
suppressMessages(suppressWarnings(library(tidyverse)))
suppressMessages(library(data.table))
suppressMessages(library(psych))

urlRemote_path  <- "https://raw.githubusercontent.com/"
github_path <- "DSHerzberg/RATING-SCALE-ANALYSIS/master/INPUT-FILES/"

data_RS_sim_child_parent <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, "data-RS-sim-child-parent.csv")
)))
data_RS_sim_child_teacher <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, "data-RS-sim-child-teacher.csv")
)))
data_RS_sim_teen_parent <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, "data-RS-sim-teen-parent.csv")
)))
data_RS_sim_teen_teacher <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, "data-RS-sim-teen-teacher.csv")
)))

# recode the input data to numerical coding for the item responses, and hold the
# resulting data frames in a list.

input_recode_list <- map(
  lst(
    data_RS_sim_child_parent,
    data_RS_sim_child_teacher,
    data_RS_sim_teen_parent,
    data_RS_sim_teen_teacher
  ),
  ~
    .x %>%
    mutate(
      across(
        contains("cpi") |
          contains("cti") | contains("tpi") | contains("tti"),
        ~ case_when(
          .x == "never" ~ 1,
          .x == "occasionally" ~ 2,
          .x == "frequently" ~ 3,
          .x == "always" ~ 4
        )
      )
    )
)


form_acronyms <- c("cp", "ct", "tp", "tt")

scale_items_suffix <- c("S1", "S2", "S3", "S4", "S5", "TOT")

scale_names <- crossing(str_to_upper(form_acronyms), scale_items_suffix) %>% 
  set_names(c("pt1", "pt2")) %>% 
  mutate(scale_names = str_c(pt1, pt2, sep = "_")) %>%
  pull(scale_names)


# To subset the input data to estimate subscale alphas, we need a list of char
# vecs containing the col names of the items in each subscale, across forms. We
# start with the "master" char vec, the TOT score (which includes all items),
# and we map `form_acronyms` to create a list of four TOT item vectors, one for
# each form.
TOT_item_names_list <- map(form_acronyms,
                           ~
                             str_c(str_c(.x, "i"), str_pad(
                               as.character(1:50), 2, side = "left", pad = "0"
                             )))

# We define a function that allows us to subset a char vec, from any starting
# position, by any fixed interval length (where "interval" refers to, e.g.,
# every fifth element).
nth_element <- function(vector, starting_position, interval) { 
  vector[seq(starting_position, length(vector), interval)] 
}

# We have k forms and j subscales, plus a TOT score for each form. Thus the list
# of all needed vectors will have a length of k*(j+1). To get this list, we use
# a nested mapping structure. On the inner call of map, the integer vector 1:5
# is the .x arg, to specify 5 starting positions (items 1-5), as the starting
# subset position for each of the five subscales. In the call of
# `nth_element()`, .x is the placeholder of the starting_position argument, .y
# is the placeholder of the vector argument, and the interval argument is fixed
# at a value of 5 (the number of subscales). 

# Within `nth_element()`, the .y argument is supplied by the outer map call. For
# this reason, we have to provide the .y = .x argument within the inner map
# call. This tells R hat the .y argument of the inner map call is being supplied
# by the .x argument of the outer map call.

# The inner map call is wrapped in `splice()` which joins two lists into a
# single list. The first argument of `splice` is the list of 5 subscale vectors
# generated by the inner map call. The 2nd argument is TOT_item_names, the .x
# argument of the outer map call, Thus the 4-element list of "master" char vecs
# (the TOT item cols for each form), functions as the .y argument of the inner
# map call AND as the .x element of the splice call. Splice thus joins a list of
# 5 subscale vectors to the TOT vector, and the outer map call ensures that this
# splicing iterates four times, once for each form.

# Finally, the list object is piped through `flatten()` to return a single flat
# list containing all 24 scale item vectors, in the required grouping order of
# all 6 vecs for one form, followed by all 6 vecs for the next form, and so on.
scale_item_vectors <- map(TOT_item_names_list,
                          ~ splice(map(1:5, ~ nth_element(.y, .x, 5), .y = .x), .x)) %>%
  flatten()



# Create list of dfs containing subscale item scores for all persons

# The next code block puts the four input datasets into a `data` list-column,
# repeating each 6 times to set up a df with 24 rows. It then puts the 24
# vectors containing the scale item names into an `item_names` list-column. It
# then creates a third list column, `items`, to hold data frames containing only
# the item columns corresponding to each scale. It does this by mapping select()
# onto the `data` and 'item_names` cols.
scale_item_data <- tibble(data = rep(
 input_recode_list,
  each = 6
),
item_names = scale_item_vectors,
scale_names = scale_names) %>%
  mutate(items = map2(data, item_names, ~ .x %>% select(all_of(.y))))
