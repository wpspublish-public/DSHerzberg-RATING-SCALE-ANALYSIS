# Load packages, read data, specify input parameters

suppressPackageStartupMessages(library(here))
suppressMessages(suppressWarnings(library(tidyverse)))
suppressMessages(library(psych))

urlRemote_path  <- "https://raw.githubusercontent.com/"
github_path <- "DSHerzberg/RATING-SCALE-ANALYSIS/master/INPUT-FILES/"

data_RS_sim_child_parent <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, "data-RS-sim-child-parent.csv")
)))
data_RS_sim_child_teacher <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, "data-RS-sim-child-teacher.csv")
)))
data_RS_sim_teen_parent <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, "data-RS-sim-teen-parent.csv")
)))
data_RS_sim_teen_teacher <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, "data-RS-sim-teen-teacher.csv")
)))

# Initialize containers for form, scale abbreviations
form_acronyms <- c("cp", "ct", "tp", "tt")

scale_items_suffix <- c("S1", "S2", "S3", "S4", "S5", "TOT")

form_scale_vecs <- map(
  c("form", "scale"),
  ~
    crossing(str_to_upper(form_acronyms), scale_items_suffix) %>%
    set_names(c("form", "scale")) %>%
    pull(!!.x)
) %>%
  set_names(c("form", "scale"))


# recode the input data to numerical coding for the item responses, and hold the
# resulting data frames in a list.

input_recode_list <- map(
  lst(
    data_RS_sim_child_parent,
    data_RS_sim_child_teacher,
    data_RS_sim_teen_parent,
    data_RS_sim_teen_teacher
  ),
  ~
    .x %>%
    mutate(
      across(
        contains("cpi") |
          contains("cti") | contains("tpi") | contains("tti"),
        ~ case_when(
          .x == "never" ~ 1,
          .x == "occasionally" ~ 2,
          .x == "frequently" ~ 3,
          .x == "always" ~ 4
        )
      )
    )
)




# To subset the input data to estimate subscale alphas, we need a list of char
# vecs containing the col names of the items in each subscale, across forms. We
# start with the "master" char vec, the TOT score (which includes all items),
# and we map `form_acronyms` to create a list of four TOT item vectors, one for
# each form.
TOT_item_names_list <- map(form_acronyms,
                           ~
                             str_c(str_c(.x, "i"), str_pad(
                               as.character(1:50), 2, side = "left", pad = "0"
                             )))

# We define a function that allows us to subset a char vec, from any starting
# position, by any fixed interval length (where "interval" refers to, e.g.,
# every fifth element).
nth_element <- function(vector, starting_position, interval) { 
  vector[seq(starting_position, length(vector), interval)] 
}

# We have k forms and j subscales, plus a TOT score for each form. Thus the list
# of all needed vectors will have a length of k*(j+1). To get this list, we use
# a nested mapping structure. On the inner call of map, the integer vector 1:5
# is the .x arg, to specify 5 starting positions (items 1-5), as the starting
# subset position for each of the five subscales. In the call of
# `nth_element()`, .x is the placeholder of the starting_position argument, .y
# is the placeholder of the vector argument, and the interval argument is fixed
# at a value of 5 (the number of subscales). 

# Within `nth_element()`, the .y argument is supplied by the outer map call. For
# this reason, we have to provide the .y = .x argument within the inner map
# call. This tells R hat the .y argument of the inner map call is being supplied
# by the .x argument of the outer map call.

# The inner map call is wrapped in `splice()` which joins two lists into a
# single list. The first argument of `splice` is the list of 5 subscale vectors
# generated by the inner map call. The 2nd argument is TOT_item_names, the .x
# argument of the outer map call, Thus the 4-element list of "master" char vecs
# (the TOT item cols for each form), functions as the .y argument of the inner
# map call AND as the .x element of the splice call. Splice thus joins a list of
# 5 subscale vectors to the TOT vector, and the outer map call ensures that this
# splicing iterates four times, once for each form.

# Finally, the list object is piped through `flatten()` to return a single flat
# list containing all 24 scale item vectors, in the required grouping order of
# all 6 vecs for one form, followed by all 6 vecs for the next form, and so on.
scale_item_vectors <- map(TOT_item_names_list,
                          ~ splice(map(1:5, ~ nth_element(.y, .x, 5), .y = .x), .x)) %>%
  flatten()



# Create list of dfs containing subscale item scores for all persons

# The next code block puts the four input datasets into a `data` list-column,
# repeating each 6 times to set up a df with 24 rows. It then puts the 24
# vectors containing the scale item names into an `item_names` list-column. It
# then creates a third list column, `items`, to hold data frames containing only
# the item columns corresponding to each scale. It does this by mapping select()
# onto the `data` and 'item_names` cols.
scale_item_data <- tibble(
  data = rep(input_recode_list,
             each = 6),
  item_names = scale_item_vectors) %>% 
  bind_cols(form_scale_cols) %>% 
  mutate(items = map2(data, item_names, ~ .x %>% select(all_of(.y))))

# for output table, extract n's, scale, mean, SDs from input data sets.
scale_n_mean_sd <- map_df(
  lst(
    data_RS_sim_child_parent,
    data_RS_sim_child_teacher,
    data_RS_sim_teen_parent,
    data_RS_sim_teen_teacher
  ),
  ~
    .x %>%
    select(contains("raw")) %>%
    describe(fast = T) %>%
    rownames_to_column() %>%
    rename(scale_name = rowname) %>%
    mutate(
      form = str_sub(scale_name, 1, 2),
      scale = str_sub(scale_name, 3,-5)
    ) %>%
    select(form, scale, n, mean, sd)
) 

# Create alpha output table with SEM, CVs, using `psych::alpha()`. Unnest the
# alpha column to get those data frames flattened out into columns.
alpha_output <- scale_item_data %>%
  mutate(alpha = map(items, ~ alpha(cor(.x))[["total"]])) %>%
  unnest(alpha) %>%
  select(form, scale, raw_alpha) %>%
  rename(alpha = raw_alpha) %>%
  left_join(scale_n_mean_sd, by = c("form", "scale")) %>%
  group_by(form) %>%
  mutate(
    SEM = sd * (sqrt(1 - alpha)),
    CV_90_UB = round(mean + 1.6449 * SEM),
    CV_90_LB = round(mean - 1.6449 * SEM),
    CV_95_UB = round(mean + 1.96 * SEM),
    CV_95_LB = round(mean - 1.96 * SEM),
    CI_90 = str_c(CV_90_LB, "--", CV_90_UB),
    CI_95 = str_c(CV_95_LB, "--", CV_95_UB),
    across(is.numeric, ~ round(., 2)),
    form = case_when(row_number() == 1 ~ form,
                     T ~ NA_character_),
    n = case_when(row_number() == 1 ~ n,
                  T ~ NA_real_)
  ) %>%
  select(form, n, scale, alpha, SEM, CI_90, CI_95) 

write_csv(alpha_output,
          here("OUTPUT-FILES/TABLES/alpha-summary-by-form.csv"),
          na = "")
