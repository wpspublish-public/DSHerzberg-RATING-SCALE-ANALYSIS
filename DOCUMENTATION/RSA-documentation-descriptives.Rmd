---
title: "Rating Scale Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Descriptives

This script generates these output files:

* Tables (.csv)
  * `freq-item-val`: item response counts
  * `freq-demos`: case counts for age range, gender, (parent) education, ethnicity, region, clinical status
  * `raw-desc`: scale raw score means, SDs

* Plots (.pdf)
  * `freq-demos`(histogram)
  * `raw-desc` (scatterplot)

The code can handle a set of input files that represent different forms (e.g., different combinations of age-range and rater). The output files are labeled analogously with `[age-range]-[rater]` nomenclature (e.g., `child-parent`, `teen-teacher`, etc.)

#### 1. Load packages, read data, specify input parameters

###### EXECUTABLE CODE
```{r descriptives-load, eval = FALSE}
suppressMessages(library(here))
suppressMessages(suppressWarnings(library(tidyverse)))
suppressMessages(library(psych))
library(ggrepel)
library(ggpubr)

urlRemote_path  <- "https://raw.github.com/"
github_path <- "wpspublish/DSHerzberg-RATING-SCALE-ANALYSIS/master/INPUT-FILES/"

data_RS_sim_child_parent <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, "data-RS-sim-child-parent.csv")
)))
data_RS_sim_child_teacher <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, "data-RS-sim-child-teacher.csv")
)))
data_RS_sim_teen_parent <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, "data-RS-sim-teen-parent.csv")
)))
data_RS_sim_teen_teacher <- suppressMessages(read_csv(url(
  str_c(urlRemote_path, github_path, "data-RS-sim-teen-teacher.csv")
)))

data_name_suffix <- c("child_parent", "child_teacher", "teen_parent", "teen_teacher")
item_col_prefix <- c("cp", "ct", "tp", "tt")
scale_col_prefix <- toupper(item_col_prefix)
var_order <- c("age_range", "gender", "educ", "ethnic", "region", "clin_status")
cat_order <- c(
  "5 to 8 yo", "9 to 12 yo", "13 to 15 yo", 
  "16 to 18 yo",
  "male", "female",
  "no_HS","HS_grad", "some_college", "BA_plus", 
  "hispanic","asian", "black", "white", "other", 
  "northeast","south", "midwest", "west",
  "typ", "clin", 
  "never", "occasionally","frequently", "always"
)

item_cols <- item_col_prefix %>% 
  map(
    ~ str_c(.x, "i", str_pad(as.character(1:50), 2, side = "left", pad = "0"))
  ) %>% 
  set_names(str_c("item_cols_", data_name_suffix))
    
item_cats <- replicate(
  4, 
  c("never", "occasionally","frequently", "always"), 
  simplify =  F
  )  %>% 
  set_names(str_c("item_cats_", data_name_suffix))
```

###### COMMENTED SNIPPETS
Load packages for file path specification (`here`), data wrangling (`tidyverse`) psychometric data simulation and analysis (`psych`), plot labeling (`ggrepel`), and formatting plots for export as .pdf (`ggpubr`).
```{r descriptives-load, echo = 1:5, eval = F}
```
Specify file paths and retrieve data from a remote host. The script reads in four input files consisting of simulated rating-scale (`RS`) data:

* `data-RS-sim-child-parent.csv`: `child` age range (5-12 yo), `parent` report
* `data-RS-sim-child-teacher`: `child` age range (5-12 yo), `teacher` report
* `data-RS-sim-teen-parent.csv`: `teen` age range (13-18 yo), `parent` report
* `data-RS-sim-teen-teacher.csv`: `teen` age range (13-18 yo), `teacher` report

```{r descriptives-load, echo = 7:21, eval = F}
```
Initialize vectors containing file, variable, and category names, abbreviations, and pre/suffixes. These vectors will be used throughout the script.
```{r descriptives-load, echo = 23:36, eval = F}
```
Initialize a list containing four character vectors whose elements are the item column names for the four input data files. `purrr::map()` iterates over the vector containing the item column prefixes (`item_col_prefix`). We apply a lambda (anonymous) function with `~` to create item column names with an `i01` to `i50` nomenclature. `stringr::str_pad()` pads a numerical sequence with zeros to the left of each number. Note the use of `base::as_character()` to coerce the number sequence `1:50` to a sequence of strings. This is wrapped in `stringr::str_c()` which concatenates the prefixes in `item_col_prefix` with the zero-padded numbers. We then use `purrr::set_names()` to name the vectors within the list, again employing `str_c()` to iteratively concatenate a prefix `"item_cols_"` with a vector of suffixes `data_name_suffix`.
```{r descriptives-load, echo = 38:42, eval = F}
```
`base::replicate()` returns a list (`item_cats`) containing four identical vectors whose elements are the item rating categories `c("never", "occasionally","frequently", "always")`. We use `set_names()` to name the vectors correspondingly to the input data files.
```{r descriptives-load, echo = 44:49, eval = F}
```

#### 2. Item Response Frequencies

The item response frequency tables provide counts of responses across the four categories for each item. The script generates a separate table for each input data file. These frequency tables are named with the prefix `freq_item_val` and saved to `.csv` in the `OUTPUT-FILES/TABLES` folder.

###### EXECUTABLE CODE
```{r descriptives-freq-item-val, eval = FALSE}
list(mget(str_c("data_RS_sim_", data_name_suffix)),
     item_cols,
     item_cats,
     data_name_suffix) %>%
  pmap(
    ~ ..1 %>%
      select(!!..2) %>%
      pivot_longer(everything(), names_to = 'item', values_to = 'value') %>%
      count(item, value) %>%
      pivot_wider(names_from = value, values_from = n) %>%
      arrange(match(item, !!..2)) %>%
      mutate(data = case_when(rownames(.) == "1" ~ ..4,
                              T ~ NA_character_)) %>%
      select(data, item, !!..3)
  ) %>%
  set_names(str_c("freq_item_val_", data_name_suffix)) %>%
  iwalk(~ write_csv(.x, here(
    str_c("OUTPUT-FILES/TABLES/",
          str_replace_all(.y, "_", "-"),
          ".csv")
  ),
  na = "")) %>%
  list2env(envir = .GlobalEnv)
```

###### COMMENTED SNIPPETS
Initialize a `list` containing the objects required to assemble the tables. We use `base::mget()` to bring the four input data files into the list. Here `mget()` returns the objects named by the character vector `str_c("data_RS_sim_", data_name_suffix)`, whose elements are the names of the four input files. Also included in this list are the `item_cols`, `item_cats`, and `data_name_suffix` vectors.
```{r descriptives-freq-item-val, echo = 1:4, eval = F}
```
`purrr::pmap()` iterates simultaneously over several inputs of equal length (here all inputs have length of four). We apply a function, designated by `~`, to these inputs in parallel. Within the body of the funtion, we refer to the inputs using a numerical shorthand. Here, `..1` refers to the first input object, the list containing the four input data files. `..2` refers to the second input object (`item_cols`), a list containing vectors of item column names for each of the four input data files. Because these names are strings, we need to unquote them, using the `!!` operator, in order to pass them to `dplyr::select()`. The data object at this point is a list, with each element a data frame containing only the item columns from the input data files.
```{r descriptives-freq-item-val, echo = 5:7, eval = F}
```
Here is the upper left corner of the `child-parent` input table, one of the four contained in the current data object.
```{r eval = F}
  cpi01  cpi02  cpi03 cpi04 cpi05 cpi06 cpi07 cpi08 cpi09 cpi10 cpi11 cpi12 cpi13 cpi14 cpi15 cpi16 cpi17

1 never  never  occa… never occa… freq… occa… freq… occa… never occa… freq… never freq… freq… freq… alwa…
2 never  frequ… freq… alwa… occa… occa… occa… freq… occa… occa… occa… never never never occa… never occa…
3 never  never  never never never never never never occa… never occa… never never occa… freq… never never
4 occas… occas… occa… occa… occa… freq… never occa… occa… freq… alwa… occa… occa… alwa… occa… freq… never
5 never  never  never never never never occa… freq… never never never alwa… alwa… occa… never occa… occa…
6 never  never  never never never occa… occa… never never never never never occa… never occa… occa… never
```

`tidyr::pivot_longer()` transforms the data object from wide to long (nested) format. The arguments to `pivot_longer()` include the `tidyselect` helper `everything()`, which indicates that all columns will be included in the transformation, and the names of the new destination columns for the input column names (`names_to`) and the input cell values (`values_to`). `pivot_longer` returns a nested data frame with two columns, `item` and `value`. In this long object, the items and their respective response values are nested within each case (person row) of the input, running down the rows for one person and then repeating the same items for the next person, and so on.

`dplyr::count()` summarizes this object. Passing `item` and `value` as arguments groups the summary object by these two variables, such that a new column `n` provides the person count for each pairing of item and response value (i.e., the first row is the number of persons that responded `always` to item `cpi01`, the second row is the number of persons that responded `frequently` to item `cpi01`, and so on). Because the input data file has 50 items, each with four possible response options, the summary object has 200 rows.
```{r descriptives-freq-item-val, echo = 8:9, eval = F}
```
Here are the first 10 rows of the `child-parent` summary table.
```{r eval = F}
   item  value            n

 1 cpi01 always          29
 2 cpi01 frequently     116
 3 cpi01 never          498
 4 cpi01 occasionally   357
 5 cpi02 always          17
 6 cpi02 frequently     163
 7 cpi02 never          453
 8 cpi02 occasionally   367
 9 cpi03 always          24
10 cpi03 frequently     138
```
Transform the summary object back to wide format using `tidyr::pivot_wider()`, the mirror-image function of `pivot_longer()`. The `names_from` and `values_from` arguments indicate that the transformed object will draw its column names from the `value` column and its cell values from the `n` column, respectively, of the input object.
```{r descriptives-freq-item-val, echo = 10, eval = F}
```
After pivoting back to wide format, the `child-parent` summary table has 50 rows (one for each item; only the first 10 are shown below). The columns to the left of `item` provide the counts for each of the four response categories, for each item.
```{r eval = F}
   item  always frequently never occasionally

 1 cpi01     29        116   498          357
 2 cpi02     17        163   453          367
 3 cpi03     24        138   474          364
 4 cpi04     29        163   442          366
 5 cpi05     35        174   426          365
 6 cpi06     34        177   410          379
 7 cpi07     41        166   401          392
 8 cpi08     35        208   366          391
 9 cpi09     46        213   352          389
10 cpi10     59        218   336          387
```
The next snippet formats and adds an additional column to the output tables. Recall that the piped data object is a list containing four summary tables. We use `dplyr::arrange()` and `base::match()` to sort each table by `item`, to a prespecified order. Within `match()`, we pass the `item` column and the match order provided by `!!..2`, which as noted previously, refers to a list containing four vectors of ordered item column names, one corresponding to each of the four summary tables in the pipeline. Wrapping `match()` in `arrange()` accomplishes the ordered sort.

`dplyr::mutate()` creates the `data` column, which identifies the data source (form name), for each of the four summary tables. With `dplyr::case_when()`, we can fill the cells of the `data` column conditionally. We want the first row of `data` to contain the form name, leaving the remaining rows `NA`. As the first argument to `case_when()`, we pass the predicate `rownames(.) == "1"`, which returns `TRUE` only for the first row of the data object, and thus isolates that row to receive a value in the `data` column. Using `~ ..4`, we supply that value from the list of form names that is the referent of `..4`, and which is iterating in parallel to the list containing the four summary tables. The second argument of `case_when()`, `T ~ NA_character_`, expresses the logical "else" condition, specifying that the value of `data` is `NA` whenever the predicate `rownames(.) == "1"` returns `FALSE`. Note the use of `NA_character_`, which is required because the `data` column is a character vector.

`select` specifies a final sequence of columns, with `!!..3` referring to the unquoted response category labels contined in the character vector `item_cats`.
```{r descriptives-freq-item-val, echo = 11:14, eval = F}
```
Here is a glimpse of the `child-parent` summary table, formatted for final output.
```{r eval = F}
   data         item  never occasionally frequently always

 1 child_parent cpi01   498          357        116     29
 2 NA           cpi02   453          367        163     17
 3 NA           cpi03   474          364        138     24
 4 NA           cpi04   442          366        163     29
 5 NA           cpi05   426          365        174     35
 6 NA           cpi06   410          379        177     34
 7 NA           cpi07   401          392        166     41
 8 NA           cpi08   366          391        208     35
 9 NA           cpi09   352          389        213     46
10 NA           cpi10   336          387        218     59
```
To recall, the data object at this point is a list of four tables summarizing the item response frequency counts for the four input files. We use `set_names()` to name the tables, employing `str_c()` to iteratively concatenate a prefix `"freq_item_val_"` with a vector of suffixes `data_name_suffix`. 

`purrr::iwalk()`, a variant of `map()`, saves the four summary tables as .csv files for external use. Rather than returning a new list, `iwalk()` returns its input (the current data object) invisibly, passing it to the next function in the pipeline. It is thus ideal to map a function that produces a "side effect" (e.g., saving external files, printing a plot, etc.).

Using `iwalk()` (as opposed to `walk()`) allows maping over both the data frames in the input list (the `.x` referent), and the _index_ of that list (i.e., the names of the data frames, the `.y` referent). To save external files, we map `readr::write_csv()` over the four data frames in the input list. We designate file paths and names for those .csv files using the `stringr` functions `str_c()` and `str_replace_all()`. The latter creates the file name suffix, replacing the `"_"` character in the index elements (`.y`) with the `"-"` character. The `na = ""` argument, passed to `write_csv()`, indicates that that `NA` cells will be recoded to empty cells in the external files.

Finally, `base::list2env()` assigns the four summary tables to the global environment `.GlobalEnv`, as separate data frames. The item response frequency tables are now available within the R programming environment, as well as externally as .csv files.
```{r descriptives-freq-item-val, echo = 16:23, eval = F}
```

#### 3. Demographic Frequency Counts

##### Tables

The demographic frequency tables provide person counts for the variables of age, gender, (parental) education level, race/ethnicity, U.S. geographical region, and clinical status. The script generates a separate table for each input data file. These frequency tables are named with the prefix `freq_demos` and saved to `.csv` in the `OUTPUT-FILES/TABLES` folder.

This code is similar to the script for the item response frequency tables, so only the differing elements are commented.

###### EXECUTABLE CODE
```{r descriptives-freq-demos-table, eval = FALSE}
list(mget(str_c("data_RS_sim_", data_name_suffix)),
     data_name_suffix) %>%
  pmap(
    ~ ..1 %>%
      select(all_of(var_order)) %>%
      pivot_longer(everything(), names_to = 'var', values_to = 'cat') %>%
      count(var, cat) %>%
      arrange(match(var, var_order), match(cat, cat_order)) %>%
      mutate(
        var = case_when(
          lag(var) == "age_range" & var == "age_range" ~ NA_character_,
          lag(var) == "gender" & var == "gender" ~ NA_character_,
          lag(var) == "educ" & var == "educ" ~ NA_character_,
          lag(var) == "ethnic" & var == "ethnic" ~ NA_character_,
          lag(var) == "region" & var == "region" ~ NA_character_,
          lag(var) == "clin_status" & var == "clin_status" ~ NA_character_,
          TRUE ~ var
        ),
        data = case_when(rownames(.) == "1" ~ ..2,
                         T ~ NA_character_)
      ) %>%
      select(data, var, cat, n)
  ) %>%
  set_names(str_c("freq_demos_", data_name_suffix)) %>%
  iwalk(~ write_csv(.x, here(
    str_c("OUTPUT-FILES/TABLES/",
          str_replace_all(.y, "_", "-"),
          ".csv")
  ),
  na = "")) %>%
  list2env(envir = .GlobalEnv)
```
###### COMMENTED SNIPPETS
`pmap()` iterates simultaneously over multiple inputs of equal length. Input `..1` is a list (assembled by `mget()`) containing the four input data files. Input `..2` is the `data_name_suffix` vector.

`select()` subsets columns from each input file for further processing. These columns are named by the previously defined vector `var_order`. A `tidyselect` helper (in this case `all_of()`) is required when passing a character vector to `select()`.
```{r descriptives-freq-demos-table, echo = 1:5, eval = F}
```
With `mutate()` and `case_when()`, we can recode specific cells of an existing column to produce a more readable output table. In the current data object, the `var` column names a demographic variable, whose categories are contained in the `cat` column. For example, one value of `var` is `region`. In the current data, object, four rows of the `var` column are coded with `region`. In the `cat` column, those four rows are coded with the categories of `region`: `northeast`,`south`, `midwest`, and `west`.
```{r eval = F}
  var    cat      

1 region northeast
2 region south    
3 region midwest  
4 region west     
```
To make the output more readable, we can recode all but the first `region` row to `NA` (which then can be recoded to blank on the final table). Within `case_when`, we specify the predicate `lag(var) == "region" & var == "region"`, which returns `TRUE` for all rows where the value of `var` is `region`, and where the value of `var` in the _preceding_ row is `region`. This captures all `region` rows except the first, where value of `var` in the preceding row is `ethnic`. The captured rows are then recoded with `~ NA_character_` to yield the transformed table:
```{r eval = F}
  var    cat      

1 region northeast
2 NA     south    
3 NA     midwest  
4 NA     west     
```

```{r descriptives-freq-demos-table, echo = 9:18, eval = F}
```

##### Histograms

Using `ggplot2` functions, this section produces a .pdf output file for each of the four age-range/rater data sets. Each .pdf includes six histograms, one for each of the six demographic variables. The .pdfs are named with the prefix `freq_demos` and saved in the `OUTPUT-FILES/PLOTS` folder. The 24 individual histograms are also viewable in the RStudio Plots pane.

###### EXECUTABLE CODE
```{r descriptives-freq-demos-hist, eval = FALSE}
map(mget(str_c("freq_demos_", data_name_suffix)), ~ .x %>% 
   fill(c(data, var))) %>%
    list2env(envir = .GlobalEnv)

hist_list <- lst(
  freq_demos_child_parent,
  freq_demos_child_teacher,
  freq_demos_teen_parent,
  freq_demos_teen_teacher
) %>%
  map( ~
         tibble(var = map(var_order, ~ .y %>% filter(var == .x), .y = .x))) %>%
  tibble(file = names(.), data1 = .) %>%
  unnest(cols = c(data1)) %>%
  mutate(plots = map2(
    var,
    file,
    ~
      print(
        ggplot(data = .x, aes(cat, n)) +
          geom_col(col = "red",
                   fill = "blue",
                   alpha = .2,
                   width = .3) +
          scale_y_continuous(breaks = seq(0, max(.x$n), round(max(.x$n) / 10, -1))) +
          labs(subtitle = str_c(
            "Demo Counts - ",
            str_replace(str_sub(.y
                                , 12), "_", " form, "),
            " report"
          )) +
          scale_x_discrete(limits = .x$cat) +
          theme(panel.grid.minor = element_blank(),
                axis.title.x = element_blank())
      )
  ))

hist_plot_prep <- map(
  map(unique(hist_list$file), ~ hist_list %>% filter(file == .x)), 
  ~ ggpubr::ggarrange(plotlist = .x$plots, ncol = 2, nrow = 2))

walk2(hist_plot_prep,
      unique(hist_list$file),
      ~ ggpubr::ggexport(.x, filename = here(
        str_c("OUTPUT-FILES/PLOTS/", str_replace_all(.y, "_", "-"),
              ".pdf")
      )))
```
###### COMMENTED SNIPPETS
The inputs to `ggplot()` are the four demographic frequency table created by the previous code. To prepare these tables for plot generation, we use `tidyr::fill()` to recode the `NA` values in the `data` and `var` columns back to their original values, as in this example:
```{r eval = F}
  data         var    cat      

1 child_parent region northeast
2 child_parent region south    
3 child_parent region midwest  
4 child_parent region west     
```

```{r descriptives-freq-demos-hist, echo = 1:3, eval = F}
```
The next section illustrates the list-column workflow, a facility provided by `purrr` that enables nested iteration. A list-column is a column within a tibble that can contain data frames, vectors, functions, plots, or any other R object that can be held in a list. To begin, we load the four input demographic frequency tables into a list, using `tibble::lst()` to name the resulting list elements with the input object names.
```{r descriptives-freq-demos-hist, echo = 5:10, eval = F}
```
This list of data frames is piped into a nested function in which `map()` is called twice. Nesting `map()` calls in this way allows the nested function to process inputs of different lengths to each `map()` call, as opposed to `pmap()`, which handles multiple inputs but requires that they be of equal lengths.

This nested function returns a list of four data frames, one corresponding to each data frame in the input list, but the returned data frames have been transformed. Each returned data frame consists of a single list-column, `var`, with six rows, one corresponding to each demographic variable in the input `freq_demos` tables (i.e., `age_range`, `gender`, `educ`, `ethnic`, `region`, `clin_status`). In each cell of the `var` column is a slice of the input data frame that contains only the rows of the `freq_demos` table corresponding to a single demographic variable (e.g., the `age_range` rows of `freq_demos` are in the first row of `var`, the `gender` rows of `freq_demos` are in the second row, and so on). 

To illustrate this transformation, the input is a data frame containing all rows for all six demographic variables, here shown partially in the top five rows of `freq_demos_child_parent`:
```{r eval = F}
   data         var         cat              n

 1 child_parent age_range   5 to 8 yo      492
 2 child_parent age_range   9 to 12 yo     508
 3 child_parent gender      male           476
 4 child_parent gender      female         524
 5 child_parent educ        no_HS          133
 ...
```
The output is a data frame with a single list-column, in which the input data frame has been split on the values of `var` into six separate tibbles, one for each demographic variable.
```{r eval = F}
  var             
  <list>          
1 <tibble [2 × 4]>
2 <tibble [2 × 4]>
3 <tibble [4 × 4]>
4 <tibble [5 × 4]>
5 <tibble [4 × 4]>
6 <tibble [2 × 4]>
```
Thus, we now have data frames nested within the rows of a "container" data frame, which is the list-column structure that allows us to generate separate histograms for each demographic variable.
 
Returning to the nested mapping function that accomplishes this transformation, recall that what is being piped into the outer call of `map()` is the list containing the four `freq_demos` tables. The outer `map()` call thus applies the function beginning with `~ tibble` iteratively to each of the four input tables.

Examining the transformation of a single input table, the call of `tibble(var = ...)` returns a tibble with the single column `var`. That column's row values are defined by the inner call of `map()`. Once this second `map()` call is invoked, the function wrapped within is dealing with two inputs: the data frame fed to the outer `map()` call (the `.y` referent), and the character vector `var_order` (the `.x` referent). In the expression `~ .y %>%  filter(var == .x)`, therefore, the input data frame (`.y`) is filtered down to only the rows where `var` is equal to the current iteration of `var_order` (`.x`). These rows are initialized as a separate data frame by `tibble()`. The `.y = .x` argument to the inner `map()` call is required to process the inputs in the correct sequence; that is, the input data frame is processed within the iterative structure that applies the elements of `var_order`, not the other way around.

It bears repeating that the output, at this stage, is a list of four named data frames, but those data frames now consist of a single list-column containing slices of the corresponding input data frames. Essentially, the input table has been carved up into segments, with each segment now residing in a row of the new list-column.
```{r descriptives-freq-demos-hist, echo = 11:12, eval = F}
```
`tibble()` reduces the list of four data frames into a single data frame with two columns and four rows. 
```{r descriptives-freq-demos-hist, echo = 13, eval = F}
```
The first column `file` contains the names of the four input data frames, which are extracted from the input list with `base::names(.)`, where `.` refers to the input list. The second column `data1` is a list-column that holds the four input data frames. Here is the resulting structure:
```{r eval = F}
  file                     data1           
  <chr>                    <named list>    
1 freq_demos_child_parent  <tibble [6 × 1]>
2 freq_demos_child_teacher <tibble [6 × 1]>
3 freq_demos_teen_parent   <tibble [6 × 1]>
4 freq_demos_teen_teacher  <tibble [6 × 1]>
```
Note that each tibble in the `data1` column has six rows; that is, one row for each of the six demographic variables. Drilling down into the top cell of `data1`, we see:
```{r eval = F}
  var             
  <list>          
1 <tibble [2 × 4]>
2 <tibble [2 × 4]>
3 <tibble [4 × 4]>
4 <tibble [5 × 4]>
5 <tibble [4 × 4]>
6 <tibble [2 × 4]>
```
This is the list-column of tibbles containing the six slices of `freq_demos_child_parent`, corresponding to the six demographic variables. Drilling down into the top cell of the `var` column, we find:
```{r eval = F}
  data         var       cat            n

1 child_parent age_range 5 to 8 yo    492
2 child_parent age_range 9 to 12 yo   508
```
This slice, which shows the `age_range` counts for the `child_parent` data set, represents the granular data elements that are needed to generate the output histograms. Essentially, we now have a single list-column that represents a nested structure (six demographic variables nested within four data sets) that resolves to the 24 granular data elements from which we will plot the 24 histograms that consitute the final output of our `ggplot()` call.

To generate the histograms, we need each granular data element to reside in its own row. In the current data object, `data1` is a nested list-column, in which the 24 granular data elements are collapsed into four rows. `tidyr::unnest(cols = c(data1))` removes one level of nesting in `data1`, transforming a four-row list-column into the required 24-row list-column. Conveniently, this operation simultaneously expands the `file` column, such that each granular data element is paired with the name of its original input file (e.g., `freq_demos_child_parent`).
```{r descriptives-freq-demos-hist, echo = 14, eval = F}
```
We now have a data structure that can be processed by `ggplot()` to generate the desired output plots. Crucially, those plots will reside in their own list-column, in the same rows as the granular data elements from which they are derived.

To create a new list-column, `plots`, within the current data object, we use `mutate()`. Here, the `plots` list-column will hold the objects returned by a call of `map2()`, which will iterate over the two existing columns in the data object, applying a `ggplot()` call to `var` and `file`.
```{r descriptives-freq-demos-hist, echo = 15:17, eval = F}
```
Note that the `ggplot()` call is wrapped in `base::print()`. This ensures that the 24 histograms will appear on the RStudio Plots pane.

Plot generation begins by passing two arguments to `ggplot()`. The first, `data = .x`, specifies that the data source for the plots will be the `.x` referent of `map2()`, which is the `var` list column that holds the 24 granular data elements. Recall the structure of these granular elements:
```{r eval = F}
  data         var       cat            n

1 child_parent age_range 5 to 8 yo    492
2 child_parent age_range 9 to 12 yo   508
```
Note that the `cat` and `n` columns are named on `aes()`, the second argument passed to `ggplot()`. `aes()` indicates how columns in the input data will be represented on the plot. The first two arguments to `aes()` are the columns that will be represented on the `x` and `y` axes of the resulting plot. Thus, with this call of `aes()`, we specify a plot that represents `cat` (the categories of a demographic variable) on the horizontal axis, and `n` (the count of cases per category) on the vertical axis. This data mapping is "global" for all subsequent graphical layers, except when it is modified by passing additional calls of `aes()` within downstream `ggplot` functions
```{r descriptives-freq-demos-hist, echo = 18:20, eval = F}
```
`ggplot()` builds plots by layering graphical elements, adding additional layers with the `+` operator. A `geom` function creates a layer that visually represents the data mapping provided by `aes()`. Here we use `geom_col()` to create a histogram. The arguments to `geom_col()` specify the visual features of the plot: the color of the outline of the vertical bars (`col`), the color of the fill of those bars (`fill`), the transparency of that fill color (`alpha`), and the width of the bars (`width`).
```{r descriptives-freq-demos-hist, echo = 21:24, eval = F}
```
Recall that `aes()` specified that the person count for demographic categories will be represented on the y-axis of the plot. `scale_y_continuous()` adds a layer that optimizes the y-axis numerical scale for the input data. The `breaks` argument specifies the numeric positions that will be represented explicitly on the vertical scale. Here we pass an ordered numeric vector returned by `base::seq()`, whose arguments are the lowest value `0`, the highest value (`max(.x$n)`, which returns the highest value in the `n` column of the input data element), and increments of `round(max(.x$n) / 10, -1)` for the middle elements of the vector. The latter expression, divides the highest `n` by 10, and rounds it to the nearest multiple of 10, by passing `-1` as an argument to `round()`.
```{r descriptives-freq-demos-hist, echo = 25, eval = F}
```
`labs()` adds a title to the plot. We pass the `subtitle` argument (as opposed to `title`) simply because it prints in a preferable type size. Within the `labs()` call, we concatenate a character string for the title using the `str_c()`, `str_replace()`, and `str_sub()` functions. Within the `str_sub()` call, we pass the `.y` referent from `map2()`, which is the `file` column. This column contains the origin file names of the granular data elements, and from these names we can extract the form/age-range configuration that we need for our plot labels, (e.g., "__Demo counts - child form, parent report__").
```{r descriptives-freq-demos-hist, echo = 26:31, eval = F}
```
We add a layer of category labels to the horizontal axis by calling `scale_x_discrete()`. Here we pass the `limits` argument, which requires a character vector that defines the possible values of the labels and their order. This vector exists as the `cat` column of the input data element, and we can pass it to `limits` with the expression `.x$cat`.
```{r descriptives-freq-demos-hist, echo = 32, eval = F}
```
We use the `theme()` layer to make global changes to the appearance of non-data plot elements. Here, `theme()` removes two unneeded visual elements, by passing the `element_blank()` function to arguments representing the minor lines on the coordinate grid (`panel.grid.minor`), and the title for the x-axis (`axis.title.x`)
```{r descriptives-freq-demos-hist, echo = 33:34, eval = F}
```
Recall that the desired external output is four .pdf files (one for each input data file), each containing six histograms (one for each demographic variable). In the next snippet, we use the `ggpubr` package to set up this .pdf output.

We initialize a list `hist_plot_prep` to hold the four objects that will be saved as .pdfs. To create these objects, we use a nested `map()` structure. With the inner `map()` call, we map over a four-element character vector, which we draw from the `file` column of `hist_list`, the data frame containing 24 histograms that we prepared in the previous code. With `unique(hist_list$file)`, we can extract only the four unique file labels from the 24 rows in the `file` column. This character vector serves as the `.x` referent in a function that filters `hist_list`, extracting on each iteration only the six rows that contain the current iteration of the `.x` file label vector in the `file` column. The inner `map()` call thus returns a list containing four six-row data frames, each of which holds six histograms in its `plots` list-column.

This list in turn constitutes the `.x` argument for the outer `map()` call. In the outer call, we apply to this list the function `ggpubr::ggarrange()`, which arranges multiple plots on a single page. Here we pass several arguments, including `plotlist`, which extracts the plots to be displayed from the `plots` list-column of the current iteration of the `.x` data frame, and `ncol` and `nrow`, which lay out the dimensions of the resulting plot grid.
```{r descriptives-freq-demos-hist, echo = 38:40, eval = F}
```
To export the four .pdfs, we use `walk2()` to iterate, because we need only the side-effect of saving an external file. To `walk2()` we pass the list of four plot grids to export `hist_plot_prep` as the `.x` argument, and a vector of names for these grids as the `.y` argument (as before, these names are extracted by `unique(hist_list$file)`). `ggpubr::ggexport()` saves out the pdfs., passing the names in `.y` to the argument `filename` to create file paths for the output.
```{r descriptives-freq-demos-hist, echo = 42:47, eval = F}
```
#### 4. Raw Score Descriptive Statistics

##### Tables

The descriptive statistics tables provide sample sizes, means, and SDs for the raw scores from five subscales, as well as for the total raw score. These frequency tables are named with the prefix `raw_desc` and saved to `.csv` in the `OUTPUT-FILES/TABLES` folder.

As before, we comment only on elements that differ from previously documented code.

###### EXECUTABLE CODE
```{r descriptives-raw-desc-tables, eval = FALSE}
list(mget(str_c("data_RS_sim_", data_name_suffix)),
     data_name_suffix) %>%
  pmap(
    ~ ..1 %>%
      select(contains('raw')) %>%
      describe(fast = T) %>%
    rownames_to_column(var = "scale") %>%
      mutate(
        data = case_when(rownames(.) == "1" ~ ..2,
                         T ~ NA_character_),
        across(c(mean, sd),
               ~ round(., 2))
      ) %>%
      select(data, scale, n, mean, sd)
  ) %>%
  set_names(str_c("raw_desc_", data_name_suffix)) %>%
  list2env(envir = .GlobalEnv)

iwalk(mget(str_c("raw_desc_", data_name_suffix)),
      ~ write_csv(.x, here(
        str_c("OUTPUT-FILES/TABLES/",
              str_replace_all(.y, "_", "-"),
              ".csv")
      ),
      na = ""))
```
###### COMMENTED SNIPPETS
In this segment, the input data objects are the four original input files of simulated rating scale data (e.g., `data_RS_sim_child_parent`). As before, `pmap()` is used to iterate over these objects, producing an output table for each.

Here we select the columns to be analyzed (the `'raw'` scores). We obtain descriptive statistics on these columns using `psych::describe()`. 
```{r descriptives-raw-desc-tables, echo = 5:6, eval = F}
```
The argument `fast = T` limits the output to the most frequently reported measures (e.g., `n`, `mean`, `sd`, `min`, `max`, `range`, `se`). These measures become column names for the summary data object, which now has a row for each score being analyzed, as in:
```{eval = F}
          vars    n  mean   sd min max range   se
CPS1_raw     1 1000 10.27 2.84   1  19    18 0.09
CPS2_raw     2 1000 10.19 2.92   2  20    18 0.09
CPS3_raw     3 1000 10.08 2.79   2  21    19 0.09
CPS4_raw     4 1000 10.30 2.79   2  21    19 0.09
CPS5_raw     5 1000 10.21 2.77   1  19    18 0.09
CPTOT_raw    6 1000 51.05 8.82  18  73    55 0.28
```
Because `describe()` converts the column names of the input object into row names, we use `tibble::rownames_to_column()` to move these row names into a column named `scale`.
```{r descriptives-raw-desc-tables, echo = 7, eval = F}
```

##### Plots

Using `ggplot2` functions, this section produces a .pdf output file for each of the four age-range/rater data sets. Each .pdf contains a plot of the means and SDs for the five subscale and `TOT` raw scores. The .pdfs are named with the prefix `raw_desc` and saved in the `OUTPUT-FILES/PLOTS` folder. The four plots are also viewable in the RStudio Plots pane.

As before, we comment only on elements that differ from previously documented code.

###### EXECUTABLE CODE
```{r descriptives-raw-desc-plots, eval = FALSE}
map(mget(str_c("raw_desc_", data_name_suffix)), ~ .x %>% 
      fill(data)) %>%
  list2env(envir = .GlobalEnv)

imap(
  .x = lst(
    raw_desc_child_parent,
    raw_desc_child_teacher,
    raw_desc_teen_parent,
    raw_desc_teen_teacher
  ),
  ~ print(
    ggplot(.x, aes(scale, mean)) +
      geom_point(
        col = "blue",
        fill = "blue",
        alpha = .5,
        size = 3,
        shape = 23
      ) +
      geom_label_repel(
        aes(label = mean),
        hjust = .7,
        vjust = -1,
        label.padding = unit(0.1, "lines"),
        size = 4,
        col = "blue"
      ) +
      scale_y_continuous(breaks = seq(0, round(max(.x$mean) + (2 * max(.x$sd)), -1), 
                                      by = round(max(.x$sd), -1) / 2), 
                         limits = c(0, round(max(.x$mean) + (2 * max(.x$sd))), -1)) +
      labs(
        title = str_c(
          "Raw Score Means (with SDs) - ",
          str_replace(str_sub(.y, 10), "_", " form, "),
          " report"
        ),
        x = "Scale",
        y = "Raw Score Mean"
      ) +
      geom_errorbar(
        aes(ymin = mean - sd, ymax = mean + sd),
        col = "red",
        size = 0.2,
        width = 0.2
      )
  )
) %>%
  iwalk(~ ggsave(plot = .x, file = here(
    str_c("OUTPUT-FILES/PLOTS/",
          str_replace_all(.y, "_", "-"), ".pdf")
  )))
```
###### COMMENTED SNIPPETS
On the input side, we set up a mapping function to generate a plot for each of four input files. Here the inputs are the four raw score descriptives tables created in the previous section. We use `imap()` to operate on both the list of four inputs (explicitly designated as the `.x` referent), and the names of those inputs (the `.y` referent).
```{r descriptives-raw-desc-plots, echo = 5:11, eval = F}
```
We call `ggplot()` and `geom_point()` to create the base layer: a univariate scatterplot in which the `scale` column of the input table is mapped to the _x_-axis, and the `mean` column is mapped to the _y_-axis.
```{r descriptives-raw-desc-plots, echo = 13:14, eval = F}
```
`ggrepel::geom_label_repel()` adds a second layer: a value label for each point. These labels are "repelled" away so that the point itself remains visible. `aes()` maps the value of `mean` into the label, and the arguments `hjust`, `vjust`, and `label.padding` control the appearance of the label and its position relative to its referent point.
```{r descriptives-raw-desc-plots, echo = 21:25, eval = F}
```
We optimize the _y_-axis numerical scale with `scale_y_continuous()`. We create robust code by setting `breaks` and `limits` not with numerical constants, but with variables calculated from the input data object. This approach generates graphical output that scales flexibly with the numerical properties of its inputs.

For example, we set the upper limit of this _y_-axis scale to `max(.x$mean) + (2 * max(.x$sd))`. Recall that we are graphing the raw score means of both `TOT` and its component subscales on the same plot. To scale the _y_-axis so that it has sufficient range to include the higher mean of `TOT`, we set the upper limit at the `max()` value of `.x$mean`, plus twice the `max()` value of `.x$sd`. The output of these expressions thus scales appropriately with the numerical properties of any input file.
```{r descriptives-raw-desc-plots, echo = 29:31, eval = F}
```
`geom_errorbar()` adds a vertical error-bar layer that depicts the standard deviation around each mean point. Within `aes()`, the arguments `ymin` and `ymax` map the lower and upper limits (respectively) of the error bar.
```{r descriptives-raw-desc-plots, echo = 41:42, eval = F}
```
The output of the outer `imap()` call is a list containing four named `ggplot` objects. This list serves as the input to `iwalk()`, which we use as before to create the side-effect of saved .pdf output. Here, `ggplot2::ggsave()` is the function that saves a named (with the `.y` referent) .pdf file for each plot (the `.x` referent).
```{r descriptives-raw-desc-plots, echo = 49:52, eval = F}
```
