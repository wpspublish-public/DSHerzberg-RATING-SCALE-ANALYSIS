---
title: "Rating Scale Analysis"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Draw a fractional subsample and compare descriptives to full sample

#### Overview

This is a supplementary method that allows assessment of equivalence between a full sample and a smaller demographically equivalent subsample. The method includes code for comparing demographic counts and raw score descriptives across the two samples. For this demonstration, we use the `data-RS-sim-child-parent.csv` data set generated by the `create-data-RSA.R` script.

#### Executable Code
```{r frac-samp-rsa, eval = FALSE}
suppressMessages(library(here))
suppressMessages(library(tidyverse))
suppressMessages(library(splitstackshape))
suppressMessages(library(psych))

sample_full <- suppressMessages(read_csv(here("INPUT-FILES/data-RS-sim-child-parent.csv")))

set.seed(1234)
sample_60perc <- stratified(sample_full,
                    c("age", "gender", "educ", "ethnic", "region"),
                    size = .6)

write_csv(sample_60perc, here(
  "INPUT-FILES/data-RS-sim-child-parent-60perc.csv"
))

demos_full <- map(
  c("gender", "educ", "ethnic", "region"),
  ~
    sample_full %>%
    group_by(age,!!sym(.x)) %>%
    summarize(n = n()) %>%
    pivot_wider(names_from = !!sym(.x), values_from = n)
) %>%
  reduce(left_join, by = "age") %>%
  ungroup() %>%
  mutate(
    sample = case_when(row_number() == 1 ~ "full",
                       TRUE ~ NA_character_),
    n = case_when(row_number() == 1 ~ nrow(sample_full),
                  TRUE ~ NA_integer_)
  ) %>%
  relocate(c(sample, n), .before = "age")

demos_60_perc <- map(
  c("gender", "educ", "ethnic", "region"),
  ~
    sample_60perc %>%
    group_by(age,!!sym(.x)) %>%
    summarize(n = n()) %>%
    pivot_wider(names_from = !!sym(.x), values_from = n)
) %>%
  reduce(left_join, by = "age") %>%
  ungroup() %>%
  mutate(
    sample = case_when(row_number() == 1 ~ "60_perc",
                       TRUE ~ NA_character_),
    n = case_when(row_number() == 1 ~ nrow(sample_60perc),
                  TRUE ~ NA_integer_)
  ) %>%
  relocate(c(sample, n), .before = "age")

demos_comp <- bind_rows(demos_full,
                        demos_60_perc)

write_csv(
  demos_comp,
  here(
    "OUTPUT-FILES/TABLES/demos-full-60perc-comp-child-parent.csv"
  ),
  na = ""
)

raw_score_desc_full_sample <- sample_full %>% 
  select(contains("raw")) %>%
  describe(fast = TRUE) %>%
  rownames_to_column(var = "scale") %>%
  select(scale, n, mean, sd)

raw_score_desc_60perc_sample <- sample_60perc %>% 
  select(contains("raw")) %>%
  describe(fast = TRUE) %>%
  rownames_to_column(var = "scale") %>%
  select(scale, n, mean, sd)

raw_score_desc_comp <- raw_score_desc_full_sample %>%
  left_join(
    raw_score_desc_60perc_sample,
    by = "scale",
    suffix = c("_full", "_60perc")
  ) %>%
  mutate(ES = abs((mean_full - mean_60perc) /
                    sqrt(((n_full*(sd_full^2)) + (n_60perc*(sd_60perc^2))) / (n_full + n_60perc)))) %>% 
  mutate(across(where(is.numeric), ~ round(., 3)))

write_csv(raw_score_desc_comp, here(
  "OUTPUT-FILES/TABLES/raw-desc-full-60perc-comp-child-parent.csv"
))
```

#### Commented Snippets
We load packages for file path specification (`here`), data wrangling (`tidyverse`), reshaping and stratifying data (`splitstackshape`), and psychometric data simulation and analysis (`psych`). We `read_csv()` the input data set into `sample_full`. 
```{r frac-samp-rsa, echo = 1:6, eval = F}
```
In this demonstration, we call `splitstackshape::stratified()` to draw a demographically-equivalent subsample `sample_60perc` containing 60% of the cases in the full sample. We use `base::set.seed()` to ensure uniform random number generation, so `stratified()` draws the same subsample every time the script is run.

We pass three arguments to `stratified()`:

* `sample_full`: the input data frame to be subsampled.
* `c("age", "gender", "educ", "ethnic", "region")`: a vector of column names that provides the grouping structure. This allows `stratified()` to sample _within_ demographic groups, thus replicating (approximately) the demographic proportions of the input data frame.
* `size = .6`: specifies that the subsample will be a certain _proportion_ of the cases in the input data frame. Because sampling takes place within a complex grouping structure, the number of cases returned will not exactly match the specified proportion.

We `write_csv()` the subsample to `.csv` for use in other procedures.
```{r frac-samp-rsa, echo = 7:15, eval = F}
```
Next we generate a table that allows comparison of case counts across demographic categories, between the full sample and the subsample.

Starting with the full sample, we use `map()` to return a list of four data frames, one for each of the four demographic variables. The names of these variables are held in a character vector (`c("gender", "educ", "ethnic", "region")`) that is the first argument to `map()`.

The second argument to `map()` is a function (set off by `~`), that is applied iteratively to the four elements of the input vector. The function extracts the case counts for each demographic variable from `full_sample`. The currently iterated demographic variable is represented in the function by the `.x` argument.

To access the counts for a variable, we first `group_by` `age` and `.x`. The variable name passed as `.x` is a quoted string, but `tidyverse` functions generally require unquoted variable inputs. We thus need to unquote the `.x` value with the bang-bang operator `!!`, followed by `rlang::sym()`.

We then call `summarize(n())` on the grouped sample, designating `n` as a summary column to hold the case counts for `.x`. At this point the piped object is a nested, long-format data frame, in which the categories of the demographic variable are represented in separate rows, repeated for each level of `age`. We call `pivot_wider()` to transform this object into a more conventional table format, in which the levels of `age` appear in the left-most column, and columns to the right hold case counts by age for each category of the demographic variable (`.x`).

```{r frac-samp-rsa, echo = 17:24, eval = F}
```
After `map()` finishes iterating, the piped object is a list of data frames, each with an identical `age` column in the left-most position. We call `purrr:reduce()` to iteratively apply `left_join()`, thus joining the unique columns of each data frame to the shared `age` column. The result is a single data frame with the `age` column on the far left, and columns corresponding to the categories of the four demographic variables proceeding to the right. Each cell of these right-ward columns holds the case counts for the crossing between an age year and a demographic category (e.g., five-year-old males).

Before modifying this new data frame, we `ungroup()`, removing the grouping structure so it does not interfere with downstream operations. We then call `mutate(case_when())` to create variables that facilitate comparison between two samples: `sample`, which identifies whether the current demographic table is for the full or fractional sample; and `n`, which gives the total number of persons in a particular sample.

The predicates within `case_when()` allow us to code the variable's value (e.g., `"full"` for `sample`) in only the first row of that column (`row_number() == 1`). This creates more readable output. We call `nrow()` to extract sample size, which is identical to the number of rows in the data frame under consideration. Finally, we use `relocate()` to obtain the desired column sequence.
```{r frac-samp-rsa, echo = 25:33, eval = F}
```
The procedure for creating the demographic table for the fractional sample is identical to that described above for the full sample. We use `bind_rows()` to stack the two tables to create a comparison table `demos_comp`.
```{r frac-samp-rsa, echo = 53:54, eval = F}
```
We create an analogous comparison table for raw score descriptive statistics using `psych::describe()`. Again starting with `sample_full`, we `select()` the raw score columns using the tidyselect helper `contains("raw")`. We call `describe()` on these columns, passing the `fast = TRUE` argument to limit the output to the most frequently reported measures (e.g., `n`, `mean`, `sd`, `min`, `max`, `range`, `se`). Because `describe()` converts the column names of the input object into row names, we use `tibble::rownames_to_column()` to move these row names into a column named `scale`. We use `select(scale, n, mean, sd)` to keep only the columns required for final output.
```{r frac-samp-rsa, echo = 64:68, eval = F}
```
As before, we use `left_join()` to create a comparison table for the descriptive statistics (`raw_score_desc_comp`). In this instance, the two input tables to be joined have identical column names. We handle this with two arguments to `left_join()`:

* `by = "scale"` aligns the input columns by scale names.
* `suffix = c("_full", "_60perc")` appends the names of incoming columns informatively, so they are easily distinguished between the two samples.

To complete the comparison table, we call `mutate()` twice: first to create an effect-size column (`ES`), and then to apply rounding to all numeric columns. We identify the latter columns with `across(where(is.numeric))`, in which `where()` is a tidyselect helper that takes a predicate function (e.g., `is.numeric()`) and collects all variables for which the function returns `TRUE`.
```{r frac-samp-rsa, echo = 76:85, eval = F}
```
